/*
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1999 - 2006 Applera Corporation.
 301 Merritt 7 
 P.O. Box 5435 
 Norwalk, CT 06856-5435 USA

 This is free software; you can redistribute it and/or modify it under the 
 terms of the GNU Lesser General Public License as published by the 
 Free Software Foundation; version 2.1 of the License.

 This software is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 or FITNESS FOR A PARTICULAR PURPOSE. 
 See the GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License 
 along with this software; if not, write to the Free Software Foundation, Inc.
 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

/**
 * Title:        Handler to generate a subject sequence report.<p>
 * Description:  Scans XML file or input for rows of a sequence-ref report.
 * @author Les Foster
 * @version $Id$
 */
package api.facade.concrete_facade.xml;

import api.entity_model.access.report.SubjectSequenceReport;
import api.entity_model.model.fundtype.EntityType;
import api.facade.abstract_facade.annotations.BlastHitFacade;
import api.facade.abstract_facade.annotations.GenewiseLoader;
import api.facade.abstract_facade.annotations.HSPFacade;
import api.facade.abstract_facade.fundtype.EntityTypeConstants;
import api.facade.concrete_facade.shared.OIDParser;
import api.facade.concrete_facade.shared.PropertySource;
import api.facade.concrete_facade.shared.feature_bean.CompoundFeatureBean;
import api.facade.concrete_facade.shared.feature_bean.FeatureBean;
import api.facade.concrete_facade.shared.feature_bean.SimpleFeatureBean;
import api.facade.concrete_facade.xml.sax_support.*;
import api.facade.facade_mgr.FacadeManager;
import shared.util.DeflineParser;

import java.util.*;

/**
 * Delegated class to handle SAX events.  It in turn delegates to handlers
 * that are used to build models.  It also keeps the primary reference to the
 * element stacks.
 */
public class SubjSeqRptHandler extends FeatureHandlerBase {
    //------------------------------MEMBER VARIABLES
    // These members are also temporary.
    private String mResultSetType = null;
    private String mAnalysisSource = null;

    private Map mFillBufferMap = null;

    private boolean mDelegatedState = false;
    private String mSource = null;

    private Set mSubjectSequenceOids;

    // Setup via constructor.
    private OIDParser mOIDParser = null;

    // Used in some cases during creation of model objects.
    private XmlFacadeManager mReadFacadeManager = null;
    private SequenceAlignment mSequenceAlignment = null;

    // Report-related.
    private SubjectSequenceReport mSubjectSequenceReport = null;

    //------------------------------CONSTRUCTORS
    /**
     * Constructor gets the first required data from the input file
     * using a SAX element scan.
     */
    public SubjSeqRptHandler(String lSource, SequenceAlignment lSequenceAlignment, OIDParser lOIDParser) {

      super(lOIDParser);

      if (lSource == null || lOIDParser == null)
        handleException(new IllegalArgumentException("Illegal construction of "+this.getClass().getName()));
      mOIDParser = lOIDParser;
      mSequenceAlignment = lSequenceAlignment;
      mSource = lSource;

      // Build chain of delegates.
      FeatureHandlerBase lCompoundFeatureHandler = new CompoundFeatureHandler();
      lCompoundFeatureHandler.setOIDParser(mOIDParser);
      setDelegate(lCompoundFeatureHandler);

      FeatureHandlerBase lSimpleFeatureHandler = new SimpleFeatureHandler(mSequenceAlignment);
      lSimpleFeatureHandler.setOIDParser(mOIDParser);
      lCompoundFeatureHandler.setDelegate(lSimpleFeatureHandler);

    } // End constructor

    //------------------------------PUBLIC INTERFACE
    /**
     * Primary method.  Returns the fully-build report against the subject
     * sequence oids given in the input set.
     */
    public void getRptLines(Set lSubjectSequenceOids, SubjectSequenceReport lReport) {
      // Construct and invoke an event handler which does a SAX parse and
      // reacts to events generated by the input file.
      GenomicsExchangeHandler eventHandler = new GenomicsExchangeHandler( new LinkedListElementStacker(),
                                                                      (FeatureHandlerBase)this);

      mSubjectSequenceOids = lSubjectSequenceOids;
      mSubjectSequenceReport = lReport;
      if (mSource != null)
        eventHandler.loadFile(mSource);
      return;

    } // End method

    //------------------------------IMPLEMENTATION OF ExceptionHandler
    /** Simply delegates to the facade manager. */
    public void handleException(Exception lException) {
      FacadeManager.handleException(lException);
    } // End method: handleException

    //------------------------------IMPLEMENTATION OF Template Methods FOR FeatureHandlerBase
    /**
     * Establish criteria for delegation to other handler.  This method decides
     * _before_ the template method is called, whether that template method will
     * even be called, or this processing will be done in the delegated handler.
     */
    public boolean delegate(ElementContext lContext, byte lProcessState) {
      String lName = lContext.currentElement();
      if (lProcessState == FeatureHandlerBase.IN_START_OF_ELEMENT) {
        if (lName.equals(CEFParseHelper.RESULT_SET_ELEMENT)) {
          mDelegatedState = true;
        } // Handle in delegate.
      } // Starting an element.
      else if (lProcessState == FeatureHandlerBase.IN_END_OF_ELEMENT) {
        if (lName.equals(CEFParseHelper.RESULT_SET_ELEMENT))
          mDelegatedState = false;
      } // Ending an element
      return mDelegatedState;
    } // End method: delegate

    /**
     * Called on subclass when element start tag encountered.
     *
     * @param String lName the name of the element.
     * @param AttributeList lAttrs the collection of tag attributes.
     */
    public void startElementTemplateMethod(ElementContext lContext) {
       // Do nothing.
    } // End method: startElementTemplateMethod

    /**
     * Called on subclass when element end tag was encountered.
     *
     * @param String lName the element which just ended.
     */
    public void endElementTemplateMethod(ElementContext lContext) {

      String lName = lContext.currentElement();

      // Decode which element is requested, sans any string comparisons.
      int foundCode = CEFParseHelper.getCEFParseHelper().translateToElementCode(lContext.currentElement());
      if (foundCode == CEFParseHelper.UNINTERESTING_ELEMENT_CODE)
        return;

      // If the end of a set occurred, we emerge from delegated,
      // and collect the set model.
      if (foundCode == CEFParseHelper.RESULT_SET_CODE) {
        ((CompoundFeatureHandler)getDelegate()).setAnalysisSource(mAnalysisSource);
        ((CompoundFeatureHandler)getDelegate()).setResultSetType(mResultSetType);

        CompoundFeatureBean model = ((CompoundFeatureHandler)getDelegate()).createModel();
        testForReportLine(model);
        model.setParent(null);
      } // End of a set element in the delegate.
      else if ((foundCode == CEFParseHelper.PROGRAM_CODE) && lContext.ancestorNumber(1).equals(CEFParseHelper.COMPUTATIONAL_ANALYSIS_ELEMENT))
        mAnalysisSource = textOfCurrentElement(lName);
      else if ((foundCode == CEFParseHelper.TYPE_CODE) && lContext.ancestorNumber(1).equals(CEFParseHelper.COMPUTATIONAL_ANALYSIS_ELEMENT))
        mResultSetType = textOfCurrentElement(lName);
      else if (foundCode == CEFParseHelper.COMPUTATIONAL_ANALYSIS_CODE) {
        ((CompoundFeatureHandler)getDelegate()).setAnalysisSource(null);
        ((CompoundFeatureHandler)getDelegate()).setResultSetType(null);  // Clear this for next computational analysis pass.
        mAnalysisSource = null;
        mResultSetType = null;
      } // End of a computational analysis.

      // Clear the buffer mapped to this element name, if there is one.
      clearMappedBuffer(lName);

    } // End method: endElementTemplateMethod

    /**
     * Called on subclass for character content.
     *
     * @param char[] lCharacters the whole buffer being constructed.
     * @param int lStart the starting point within the buffer.
     * @param int lLength the ending point within the buffer.
     */
    public void charactersTemplateMethod(char[] lCharacters, int lStart, int lLength, ElementContext lContext) {
      // Do nothing.
    } // End method: charactersTemplateMethod

    /**
     * Returning the fill buffer map allows values to be assigned to buffers
     * local to this handler.
     */
    public Map getFillBufferMapTemplateMethod() {
      if (mFillBufferMap == null)
        initializeFillBufferMap();

      return mFillBufferMap;
    } // End method: getFillBufferMapTemplateMethod

    //----------------------------HELPER METHODS
    /**
     * Checks the model against criteria.  If it matches, adds to the
     * report as another line.
     */
    private void testForReportLine(CompoundFeatureBean lModel) {
      if (lModel == null)
        return;

      if (! hasChildWithSubjectSequenceOidOfInterest(lModel))
        return;

      String lDescription = lModel.getDescription();
      String lAccession;
      if (lDescription != null) {
        DeflineParser lDescriptionParser = new DeflineParser(lDescription);
        lAccession = "";
        Iterator it = lDescriptionParser.getAllAltIds();
        if (it.hasNext()) {
          it.next(); // Discard first iteration.
          if (it.hasNext()) {
            lAccession = lAccession + (String)it.next();
          } // Has second
        } // Has first
      } // Have description
      else {
        lAccession = "";
        lDescription = "";
      } // No description

      EntityType entityType = lModel.decodeEntityType(lModel.getAnalysisType());
      switch (entityType.value()) {
        case EntityTypeConstants.BlastN_Hit:
        case EntityTypeConstants.BlastX_Hit: {
          SubjectSequenceReport.BlastHitReportLineItem lineItem = null;
          lineItem = new SubjectSequenceReport.BlastHitReportLineItem(
                        lModel.getOID(),
                        lModel.getAxisOfAlignment(),
                        lModel.getAxisOfAlignment().toString(),
                        lModel.getAnalysisType(),
                        lModel.getStart(),
                        lAccession,
                        lDescription);
          mSubjectSequenceReport.addLineItem(lineItem);
        } // Got a blast hit.
        break;

        case EntityTypeConstants.Sim4_Hit: {
          SubjectSequenceReport.Sim4ReportLineItem lineItem = null;
          lineItem = new SubjectSequenceReport.Sim4ReportLineItem(
                          lModel.getOID(),
                          lModel.getAxisOfAlignment(),
                          lModel.getAxisOfAlignment().toString(),
                          lModel.getAnalysisType(),
                          lModel.getStart(),
                          lAccession,
                          lDescription,
                          findInSources(lModel, BlastHitFacade.PERCENT_HIT_IDENTITY_PROP));
          mSubjectSequenceReport.addLineItem(lineItem);
        } // Got a sim4 hit.
        break;

        case EntityTypeConstants.Genewise_Peptide_Hit: {
          SubjectSequenceReport.GenewiseReportLineItem lineItem = null;
          lineItem = new SubjectSequenceReport.GenewiseReportLineItem(
                          lModel.getOID(),
                          lModel.getAxisOfAlignment(),
                          lModel.getAxisOfAlignment().toString(),
                          lModel.getAnalysisType(),
                          lModel.getStart(),
                          lAccession,
                          lDescription,
                          getNumSimilar(lModel),
                          findInSources(lModel, BlastHitFacade.PERCENT_HIT_IDENTITY_PROP));
          mSubjectSequenceReport.addLineItem(lineItem);
        } // Got a genewise hit.
        break;

        default:
        break;
      }

    } // End method

    //-------------------------------------------HELPERS
    /** Pulling in a num similar or positive. */
    private int getNumSimilar(CompoundFeatureBean lModel) {
      String lPropVal = findInSources(lModel, GenewiseLoader.NUM_SIMILAR_PROP);
      int lReturnVal = 0;
      try {
        lReturnVal = Integer.parseInt(lPropVal);
      } catch (Exception ex) {
        // Just return the default.
      } // Failed

      return lReturnVal;
    } // End method

    /**
     * GO through child models looking for highest bit score.
     */
    private double getMaxBitScore(CompoundFeatureBean lModel) {
      double highestBitScore = Double.MIN_VALUE;
      SimpleFeatureBean lChildModel = null;
      String score = null;
      double nextScore = 0;
      for (Iterator it = lModel.getChildren().iterator(); it.hasNext(); ) {
        lChildModel = (SimpleFeatureBean)it.next();
        if (null != (score = getBitScore(lChildModel))) {
          try {
            nextScore = Double.parseDouble(score);
          } // End try
          catch (NumberFormatException nfe) {
            continue;
          } // ENd catch

          if (nextScore > highestBitScore)
            highestBitScore = nextScore;
        } // GOt non-null score
      } // For all children

      // Signal "sum" with no increments.
      if (highestBitScore == Double.MIN_VALUE)
        highestBitScore = 0.0;

      return highestBitScore;
    } // End method

    /** Method to find value for name from the model's prop sources. */
    private String findInSources(FeatureBean lModel, String lName) {
      List lPropertySources = lModel.getPropertySources();
      PropertySource lNextSource = null;
      for (Iterator it = lPropertySources.iterator(); it.hasNext(); ) {
        lNextSource = (PropertySource)it.next();
        if (lName.equals(lNextSource.getName()))
          return lNextSource.getValue();
      } // For all p-sources
      return null;
    } // End method

    /** Method to find the bit score from among all different possible locs. */
    private String getBitScore(SimpleFeatureBean lChildModel) {
      String bitScoreStr = findInSources(lChildModel, HSPFacade.BIT_SCORE_PROP);
      if (bitScoreStr == null)
        bitScoreStr = lChildModel.getScore();
      return bitScoreStr;
    } // End method

    /**
     * Check whether any child of the model has a subjects sequence oid
     * that appears in the set of oids of interest.
     */
    private boolean hasChildWithSubjectSequenceOidOfInterest(CompoundFeatureBean lModel) {

      boolean returnFlag = false;
      SimpleFeatureBean lChildModel = null;

      // Look for containment of child's subj-seq-oid in the collection of
      // interesting subj-seq-oids.
      for (Iterator it = lModel.getChildren().iterator(); (!returnFlag) && it.hasNext(); ) {
        lChildModel = (SimpleFeatureBean)it.next();
        if (mSubjectSequenceOids.contains(lChildModel.getSubjectSequenceOid()))
          returnFlag = true;
      } // For all iterations

      return returnFlag;
    } // End method

    /**
     * Sets up the mapping of element names to buffers to be filled
     * with their contents.
     */
    private void initializeFillBufferMap() {
      mFillBufferMap = new HashMap();

      // For precomputes...
      mFillBufferMap.put(CEFParseHelper.PROGRAM_ELEMENT, null);
      mFillBufferMap.put(CEFParseHelper.TYPE_ELEMENT, null);

    } // End method: initializeFillBufferMap

} // End class

/*
 $Log$
 Revision 1.2  2011/03/08 16:16:39  saffordt
 Java 1.6 changes

 Revision 1.1  2006/11/09 21:35:56  rjturner
 Initial upload of source

 Revision 1.30  2002/11/07 16:06:16  lblick
 Removed obsolete imports and unused local variables.

 Revision 1.29  2002/10/21 18:10:32  lblick
 Removed alternate accession from the subject sequence report.

 Revision 1.28  2002/05/10 21:21:45  lfoster
 Added GeneWise num similar to report, and eliminated some unused methods.

 Revision 1.27  2002/05/10 18:56:14  srinivdn
 Moved the SUM_E_VAL property from BlastHitFacade to HSPFacade.

 Revision 1.26  2002/05/09 20:23:05  srinivdn
 removing summary_e_value from the parent blasthit in property
 and subject sequence report.

 Revision 1.25  2002/05/07 19:24:13  lfoster
 Setting default values for max bit score and min sum e value.

 Revision 1.24  2002/04/22 14:46:33  lfoster
 Removed extra blank.

 Revision 1.23  2002/04/19 21:54:15  lfoster
 Added sum e val to sub seq hdlr for sub seq rpt.

 Revision 1.22  2002/04/19 21:09:41  lfoster
 Property modifications.  Added some items to subj seq report view for XML

 Revision 1.21  2002/04/19 20:04:27  lfoster
 Added description, accession, and alt accession to subj seq rpt.

 Revision 1.20  2002/04/19 18:26:13  srinivdn
 Changed pct_hit_identity type

 Revision 1.19  2002/04/19 14:31:28  srinivdn
 Stubbed for the new attributes on subject sequence report.

 Revision 1.18  2002/04/05 19:48:44  lfoster
 Removed refs to FacadeManager from sax support classes.  Wrapped facademanager handleexception calls in instance method calls.

 Revision 1.17  2002/04/05 19:06:57  lfoster
 Moved 8 classes from xml down to xml.sax_support.  Removed dep of PropertySource on abstract facades.

 Revision 1.16  2002/03/06 21:06:40  lfoster
 Sending request to servlet for Subject Sequence Report.

 Revision 1.15  2002/03/05 16:13:59  lfoster
 Subject Sequence Report now looking at property sources instead of just obsoleted "score" and "output" tags for sum e val and bit score.

 Revision 1.14  2002/03/05 15:38:54  lfoster
 Removed useless (confusing) method, and corrected some whitespacing.

 Revision 1.13  2001/08/28 18:47:37  simpsomd
 Updated subject sequence report to include the axis id

 Revision 1.12  2001/08/28 13:26:03  lfoster
 Switched over to SAX version 2.0 in all parsers.

 Revision 1.11  2001/08/27 13:49:41  simpsomd
 Added Feature ID field to Subject Sequence Report

 Revision 1.10  2001/05/22 22:28:30  lfoster
 Eliminated unused variable.

 Revision 1.9  2001/05/22 21:22:45  lfoster
 Factored out the LinkedListElementStacker so that the element stacker would not be multiply defined as an inner class in many other classes.

 Revision 1.8  2001/05/21 22:07:42  simpsomd
 Replaced hard-coded strings with constants defined in
 api.facade.abstract_facade.fundtype.EntityTypeConstants

 Revision 1.7  2001/05/17 21:40:34  lfoster
 Fixed problem whereby Sequence ALignment facade was returning multiple alignments to single features.

 Revision 1.6  2001/05/11 21:23:11  lfoster
 Eliminated constants defined in FeatureHandlerBase in favor of those in CEFParseHelper.  Converted more loaders/handlers to use the hashmap/code method to identify elements rather than string comparisons.

 Revision 1.5  2001/04/27 19:11:12  lfoster
 From int to double on report line generation.

 Revision 1.4  2001/04/24 21:33:48  lfoster
 Closer to real values.  Must confirm accuracy with Marian.

 Revision 1.3  2001/04/24 20:10:22  lfoster
 Probably not populating report, but no longer stack overflow on SubjectSequence report.

 Revision 1.2  2001/04/24 04:10:05  lfoster
 Null-proofed create method, and now getting feature type from model decoder.

 Revision 1.1  2001/04/23 22:34:53  lfoster
 Added code for dealing with subject sequence report.

 */
